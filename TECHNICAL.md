# Техническая документация CherryPlayList

## Стек технологий

### Основной стек

- **Electron** - платформа для создания десктопных приложений
- **React** - библиотека для построения пользовательского интерфейса
- **TypeScript** - типизированный JavaScript для повышения надежности кода
- **Zustand** - легковесная библиотека для управления состоянием приложения

### Обоснование выбора стека

#### Electron

- Кроссплатформенность (Windows, macOS, Linux)
- Нативная поддержка Drag & Drop через HTML5 API
- Доступ к файловой системе через Node.js API
- Богатая экосистема npm-пакетов

#### React

- Компонентный подход для создания переиспользуемых UI-элементов
- Большая экосистема библиотек для drag & drop (react-beautiful-dnd, dnd-kit)
- Виртуальный DOM для оптимизации производительности
- Активное сообщество и множество готовых решений

#### TypeScript

- Статическая типизация для предотвращения ошибок
- Улучшенная поддержка IDE (автодополнение, рефакторинг)
- Лучшая читаемость и поддерживаемость кода
- Совместимость с существующим JavaScript-кодом

#### Zustand

- Легковесная библиотека для управления состоянием (менее 1KB)
- Простой API без boilerplate кода
- Отлично работает с TypeScript
- Поддержка middleware для персистентности и devtools
- Идеально подходит для небольших и средних приложений
- Не требует провайдеров и оберток компонентов

## Технические требования

### Платформа

- **Выбранная платформа**: Electron
- Операционная система: Windows 10/11 (текущая разработка)
- Поддержка локальных аудиофайлов

### Поддерживаемые форматы аудио

- MP3
- WAV
- FLAC
- M4A
- OGG
- (список может быть расширен)

## Анализ выбора платформы: Electron

### Плюсы Electron для CherryPlayList

1. **Кроссплатформенность**
   - Возможность запуска на Windows, macOS и Linux из одной кодовой базы
   - Единый код для всех платформ упрощает поддержку

2. **Быстрая разработка UI**
   - Использование веб-технологий (HTML, CSS, JavaScript/TypeScript)
   - Богатая экосистема UI-библиотек (React, Vue, Angular и др.)
   - Легко создать современный и красивый интерфейс

3. **Нативная поддержка Drag & Drop**
   - HTML5 Drag and Drop API работает из коробки
   - Можно использовать библиотеки типа react-beautiful-dnd, dnd-kit для более продвинутого функционала
   - Нативная поддержка перетаскивания файлов из файловой системы

4. **Доступ к файловой системе**
   - Node.js API для работы с файлами (fs, path)
   - Простое копирование и переименование файлов
   - Доступ к метаданным файлов через библиотеки (music-metadata, node-id3)

5. **Большая экосистема**
   - Огромное количество npm-пакетов для работы с аудио
   - Библиотеки для парсинга метаданных треков
   - Готовые решения для многих задач

6. **Гибкость и расширяемость**
   - Легко добавить новые функции экспорта
   - Возможность интеграции с веб-сервисами в будущем
   - Простое добавление плагинов и расширений

7. **Знакомые технологии**
   - Если разработчик знает веб-технологии, кривая обучения минимальна
   - Легко найти разработчиков для проекта

### Минусы Electron для CherryPlayList

1. **Размер приложения**
   - Electron включает Chromium и Node.js, что увеличивает размер дистрибутива
   - Типичный размер: 100-150 MB (может быть критично для простого приложения)
   - Больше места на диске для пользователей

2. **Потребление ресурсов**
   - Выше потребление RAM по сравнению с нативными приложениями
   - Chromium может потреблять 100-300 MB RAM даже для простого приложения
   - Может быть избыточно для простой задачи управления плейлистами

3. **Производительность**
   - Для простых операций (копирование файлов, переименование) производительность достаточна
   - Для сложной обработки аудио может быть медленнее нативных решений
   - Но для задач проекта (drag & drop, копирование файлов) производительность более чем достаточна

4. **Безопасность**

   Electron имеет специфические проблемы безопасности, связанные с архитектурой приложения:

   **Основные проблемы:**

   a) **Context Isolation (Изоляция контекста)**
   - По умолчанию в старых версиях Electron код в renderer процессе (UI) имел прямой доступ к Node.js API
   - Это создавало уязвимости, если в UI загружался внешний контент
   - **Решение**: Включить `contextIsolation: true` в настройках BrowserWindow
   - **Для CherryPlayList**: Не критично, так как приложение работает только с локальными файлами, но все равно рекомендуется включить

   b) **Node Integration**
   - Прямой доступ к Node.js из renderer процесса может быть опасен
   - Если в приложении загружается внешний HTML/JS (например, из интернета), злоумышленник может получить доступ к файловой системе
   - **Решение**: Отключить Node Integration (`nodeIntegration: false`) и использовать IPC (Inter-Process Communication) для взаимодействия с main процессом
   - **Для CherryPlayList**: Важно настроить правильно, так как приложение работает с файлами

   c) **Remote Module (устарел)**
   - Модуль `remote` позволял вызывать методы main процесса из renderer
   - Создавал уязвимости и был удален в Electron 14+
   - **Для CherryPlayList**: Не актуально, так как используем современные версии Electron

   d) **Content Security Policy (CSP)**
   - Отсутствие CSP позволяет выполнять произвольный JavaScript
   - **Решение**: Настроить строгую CSP в HTML
   - **Для CherryPlayList**: Рекомендуется, но не критично для полностью локального приложения

   e) **Валидация путей файлов**
   - При работе с файлами необходимо проверять пути на path traversal атаки (например, `../../../etc/passwd`)
   - **Решение**: Использовать `path.resolve()` и проверять, что путь находится в разрешенной директории
   - **Для CherryPlayList**: **Важно!** При копировании файлов нужно валидировать пути

   **Вывод для CherryPlayList:**
   - Для локального приложения, работающего только с локальными файлами, большинство проблем менее критичны
   - Но все равно необходимо:
     - Включить `contextIsolation: true`
     - Отключить Node Integration (`nodeIntegration: false`) в renderer процессе
     - Использовать IPC для работы с файлами
     - Валидировать пути при работе с файловой системой
   - Это стандартные практики безопасности Electron, которые не усложняют разработку значительно

5. **Обновления**
   - Зависимость от обновлений Electron и Chromium
   - Необходимо следить за безопасностью и обновлениями

6. **Альтернативы для простых задач**
   - Для очень простого приложения может быть избыточно
   - Нативные решения (C#/.NET, Python + Tkinter/PyQt) могут быть легче
   - Но Electron дает больше гибкости для будущего развития

### Вывод для CherryPlayList

**Electron - хороший выбор** для данного проекта, потому что:

- Drag & Drop - ключевая функция, и веб-технологии отлично с этим справляются
- Быстрая разработка современного UI важна
- Работа с файлами через Node.js проста и надежна
- Возможность легко расширять функционал в будущем
- Кроссплатформенность может быть полезна позже

## Архитектура приложения

### Структура проекта

```
CherryPlayList/
├── electron/              # Main процесс Electron (в корне проекта)
│   ├── main.ts           # Точка входа Electron
│   ├── preload.ts        # Preload скрипт для безопасного IPC
│   ├── ipc/              # IPC handlers
│   └── utils/            # Утилиты
├── src/                  # Renderer процесс (React UI)
│   ├── components/       # React компоненты
│   ├── hooks/            # React hooks
│   ├── state/            # Zustand stores (state management)
│   ├── services/         # Сервисы
│   ├── types/            # TypeScript типы
│   ├── App.tsx           # Главный компонент
│   └── index.tsx         # Точка входа React
├── public/               # Статические файлы (иконки, изображения)
├── plugins/              # Плагины
├── index.html            # HTML точка входа (в корне, не в public/)
├── vite.config.mjs       # Vite конфигурация (ESM, не .ts)
├── tsconfig.json         # TypeScript конфигурация для React
├── tsconfig.electron.json # TypeScript конфигурация для Electron
├── tsconfig.node.json    # TypeScript конфигурация для Node.js
├── package.json
└── .gitignore
```

**Важно:**

- `electron/` находится в корне проекта, не в `src/`
- `index.html` находится в корне проекта, не в `public/`
- `vite.config.mjs` использует расширение `.mjs` (ESM), не `.ts`

### Компоненты приложения

1. **Обозреватель файлов** - просмотр и выбор треков из локальной библиотеки
2. **Редактор плейлиста** - область для формирования последовательности треков
3. **Система перетаскивания** - универсальный механизм drag & drop для управления треками:
   - **Workspace-agnostic дизайн**: Система не зависит от конкретных типов workspace (playlist, collection и т.д.), работает с любыми track-based workspace через workspace ID
   - Реализовано на нативном HTML5 Drag and Drop API (без внешних библиотек)
   - Перетаскивание элемента целиком (атрибут `draggable={true}`)
   - Перетаскиваемый элемент становится полупрозрачным (opacity: 0.5)
   - Тонкая синяя линия-вставка (`drag-insert-line`) показывает место вставки между карточками
   - Линия появляется сверху или снизу элемента в зависимости от позиции курсора (верхняя/нижняя половина элемента)
   - Линия имеет анимацию пульсации для лучшей видимости
   - Элементы не подсвечиваются при наведении (используется только линия вставки)
   - Плавная анимация при перемещении после отпускания
   - Корректный расчет индексов с учетом смещения при перемещении вниз по списку
   - **Cross-workspace операции**: Перетаскивание треков между любыми workspace (playlist ↔ collection, collection ↔ collection и т.д.)
   - **Копирование с Ctrl/Cmd**: Состояние клавиши Ctrl/Cmd определяется в `handleDragOver` и сохраняется в `draggedItems.isCopyMode` для использования в `handleDrop`
   - **Централизованное управление**: Все cross-workspace операции проходят через `dragDropStore`, который использует workspace ID для поиска stores
4. **Модуль экспорта** - обработка и копирование треков с нумерацией

### Основные операции

- Загрузка треков из файловой системы
- Добавление трека в плейлист (drag & drop или клик)
- Переупорядочивание треков в плейлисте (drag & drop)
- Удаление трека из плейлиста
- Экспорт плейлиста в папку с нумерацией

### IPC (Inter-Process Communication)

Коммуникация между main и renderer процессами будет осуществляться через IPC:

- `ipcMain.handle()` - обработка запросов из renderer
- `ipcRenderer.invoke()` - вызовы из renderer в main
- Каналы для работы с файлами:
  - `file:read` - чтение файлов
  - `file:copy` - копирование файлов
  - `file:getMetadata` - получение метаданных треков
  - `file:exportPlaylist` - экспорт плейлиста

### Рекомендуемые библиотеки

#### Для Drag & Drop

- **Реализовано на нативном HTML5 Drag and Drop API** - не требуются внешние библиотеки
- Используются стандартные браузерные события: `dragstart`, `dragover`, `drop`, `dragend`
- Атрибут `draggable` для элементов
- React обработчики: `onDragStart`, `onDragOver`, `onDrop`, `onDragEnd`
- Визуальная обратная связь через CSS классы и условный рендеринг линии вставки

#### Для работы с аудио

- `music-metadata` - парсинг метаданных аудиофайлов
- `node-id3` - работа с ID3 тегами MP3

#### Для UI

- `styled-components` или `emotion` - CSS-in-JS (опционально)
- Или обычный CSS/SCSS модули
- **Material Icons** - библиотека иконок
- Подробная спецификация дизайна UI/UX находится в `FULL_DOCUMENTATION.md`, раздел 9

#### Для state management

- `zustand` - управление состоянием приложения

#### Для сборки

- `webpack` или `vite` - бандлер
- `electron-builder` - упаковка приложения для распространения
- `concurrently` - для параллельного запуска Vite и Electron в dev режиме
- `wait-on` - для ожидания запуска Vite dev server перед запуском Electron

### Важные нюансы настройки Vite + Electron

1. **Vite конфигурация:**
   - Файл должен быть `vite.config.mjs` (ESM формат), не `vite.config.ts`
   - Vite 5+ требует ESM для конфигурации
   - Использовать `import.meta.url` для получения `__dirname` в ESM

2. **index.html:**
   - Должен находиться в корне проекта, не в `public/`
   - Vite использует его как точку входа для сборки

3. **TypeScript для Electron:**
   - Отдельный `tsconfig.electron.json` с `"module": "CommonJS"`
   - Можно использовать ES6 импорты в исходниках, TypeScript скомпилирует в CommonJS
   - Скомпилированные файлы в `dist-electron/electron/` (сохраняется структура папок)

4. **package.json:**
   - `"main"` должен указывать на `"dist-electron/electron/main.js"`
   - Скрипт `dev` должен компилировать Electron код перед запуском

## Настройки безопасности Electron

### Рекомендуемая конфигурация BrowserWindow

```typescript
new BrowserWindow({
  webPreferences: {
    nodeIntegration: false, // Отключить прямой доступ к Node.js
    contextIsolation: true, // Включить изоляцию контекста
    enableRemoteModule: false, // Отключить remote модуль
    preload: path.join(__dirname, 'preload.js'), // Preload скрипт для безопасного IPC
  },
});
```

### Preload скрипт

Preload скрипт будет использоваться для безопасного предоставления API renderer процессу через `contextBridge`.

### Content Security Policy (CSP)

Content Security Policy настроена в `index.html` для дополнительной защиты:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; script-src 'self' 'unsafe-inline' https://fonts.googleapis.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;"
/>
```

Эта политика ограничивает:

- Скрипты: только с того же источника и inline скрипты (требуется для Vite)
- Стили: только с того же источника, inline стили и Google Fonts
- Шрифты: только с того же источника и Google Fonts
- Все остальные ресурсы: только с того же источника

### Валидация путей файлов

#### Текущая реализация

Валидация путей реализована в `electron/utils/fsHelpers.ts` через функцию `validatePath()`. Эта функция:

- Проверяет, что путь является непустой строкой
- Разрешает и нормализует путь с помощью `path.resolve()`
- Если указан `basePath`, проверяет, что разрешенный путь находится внутри базового пути
- Блокирует пути, которые разрешаются вне базового пути

#### Требования к валидации путей

**Критическое требование**: Когда `basePath` не указан, пути, содержащие `..`, должны быть заблокированы для предотвращения path traversal атак. Текущая реализация позволяет `..` в путях, когда `basePath` не указан, что может быть уязвимостью безопасности.

**Требуемое исправление**: Функция `validatePath()` должна блокировать пути с `..` когда `basePath` не предоставлен:

```typescript
export function validatePath(userPath: string, basePath?: string): boolean {
  if (!userPath || typeof userPath !== 'string') {
    return false;
  }

  // Блокировать пути с .. если basePath не указан
  if (!basePath && (userPath.includes('..') || userPath.includes('~'))) {
    return false;
  }

  // ... остальная валидация
}
```

#### Проверка существования файлов

**Требование**: Перед выполнением операций с файлами (копирование, чтение и т.д.) код должен проверять существование исходных файлов с помощью `fs.access()` или `fs.stat()`. Это обеспечивает лучшую обработку ошибок и предотвращает ненужные операции.

**Текущий статус**: Некоторые обработчики проверяют существование файлов (например, `audio:getDuration`), но функции экспорта не проверяют существование исходных файлов перед копированием.

**Рекомендуемая реализация**:

```typescript
// Перед копированием файла
await fs.access(sourcePath);
await copyFile(sourcePath, destPath);
```

## Планы развития технической части

### Функциональные улучшения

- **Отображение общей длительности треков в плейлисте**
  - Добавление поля `duration` в тип `Track`
  - Интеграция библиотеки для извлечения метаданных аудио (music-metadata или ffprobe)
  - Реализация UI компонента для отображения общей длительности
  - Форматирование длительности в читаемый вид

- **Выделение и групповое управление треками**
  - Расширение `playlistStore` для поддержки множественного выбора
  - Реализация логики выделения (Ctrl+Click, Shift+Click)
  - Добавление групповых операций (перемещение, удаление)
  - Визуальное выделение выбранных треков в UI

- **Экспорт в формате AIMP с относительными путями**
  - Изучение формата плейлиста AIMP (.m3u8, .pls)
  - Создание новой стратегии экспорта `AIMPPlaylistStrategy`
  - Реализация функции преобразования абсолютных путей в относительные
  - Обеспечение переносимости плейлистов при перемещении папок

### Технические улучшения

- Настройка CI/CD для автоматической сборки
- Добавление тестирования (Jest, React Testing Library)
- Оптимизация размера бандла
- Добавление hot reload для разработки
- Настройка линтеров и форматтеров (ESLint, Prettier)
